
## 1. Distributed mutual exclusion
- 분산형 프로세스는 종종 그들의 활동을 조정할 필요가 있다.
  - 프로세스들이 자원을 공유할 경우 개입을 방지하고 일관성을 보장하기 위해 mutual exclusion이 필요하다.
  - critical section problem

### 1.1.
#### 1.1.1. Assumptions
async system, process not fail, message delivery is reliable.

#### 1.1.2. The application-level protocol for executing a critical section
enter(), resourceAccesses(), exit()

#### 1.1.3. Requirements for mutual exclusion
- ME1 (safety)
  - 한 번에 최대 한 개의 프로세스가 CS를 실행할 수 있다.
- ME2 (liveness)
  - CS에 들어가거나 나가기 위한 요청은 항상 성공해야 한다.
- ME3 (ordering)
  - enter 요청이 먼저 온 것은 먼제 승인 되도록 해야 한다.

#### 1.1.4. Criteria to evaluate algorithms for mutual exclusion
- Bandwidth : entry, exit 작업에 보내지는 메시지가 전체 통신에서 차지하는 비율
- Client delay : entry, exit 작업 때 프로세스에서 발생하는 지연
- Throughput : 전체 프로세스들이 CS에 접근할 수 있는 속도
  - 한 프로세스가 exit하고 다른 프로세스가 enter할 때 동기화 지연을 가지고 측정

### 1.2. Algorithms
#### 1.2.1. The central server algorithm
- CS에 들어가려면 프로세스는 요청을 서버에 보내고 대답을 기다려야 함
- 요청할 때 다른 프로세스가 토큰을 갖고 있지 않으면 서버는 바로 대답하며 토큰을 준다.
- 만약 누군가가 토큰을 가지고 있으면 서버는 대답하지 않으며, 요청을 큐에 넣는다.
- CS를 나갈 때 나간다는 메시지를 서버에게 보내며, 토큰을 반납한다.
- 만약 기다리는 프로세스가 존재하면 서버는 가장 오래된 요청에 대답해 준다.

safety, liveness는 만족하는데 ordering은 만족하지 않는다. (?)       
CS에 들어가기 위해서는 두 메시지가 필요하다 : 요청, 승인    
CS에 나가기 위해서는 한 메시지가 필요하다 : 나간다.    

#### 1.2.2. A ring-based algorithm
- N개의 프로세스들을 ring에 배치함.
- 각 프로세스 pi는 다음 프로세스인 p(i+1 mod N)으로의 통신 채널을 가지고 있다.
- Exclustion은 프로세스에서 처리로 전달되는 메시지 형식의 토큰을 획득하여 부여된다.
- 만약 프로세스가 CS로 안 들어가려고 하는데 토큰을 받으면 그냥 바로 이웃에게 넘겨버린다.
- CS에 나가기 위해서는 토큰을 이웃에게 넘겨버린다.

safety, liveness는 만족하는데 ordering은 만족하지 않는다.    
CS 진입 요청에 대한 지연 시간은 0부터 N개의 메시지 만큼.    
CS 나갈 때 필요한 메시지는 1개    
한 프로세스가 CS 나갈 때와 다른 프로세스가 CS에 들어갈 때의 동기화 시간은 1 부터 N개의 메시지 전송 시간

#### 1.2.3. An algorithm using multicast and logical clocks
- CS에 들어가기 위해 프로세스들에게 요청을 멀티 캐스트하고 모든 다른 프로세스가 답장해줄 때에만 진입 가능
- Assumption
  - 모든 프로세스가 서로 다른 숫자 아이디를 가지고 있다.
  - 서로 간의 통신 채널이 있고 모든 프로세스는 Lamport clock을 유지한다.
  - 진입 요청 메시지는 <Ti, pi> 형태 이다. T는 전송자의 타임 스탬프, pi는 전송자의 아이디.
- States of each process
  - RELEASED, WANTED, HELD

- 한 프로세스가 진입 요청을 하고 다른 모든 프로세스들이 RELEASED 상태라면 모든 프로세스들은 바로 답장을 해준다.
- 만안 어떤 프로세스가 HELD라면 그 프로세스는 CS에서 나갈 때 까지 답장을 해주지 않고 요청자는 잠시 동안 진입하지 못한다.
- 만약 두 개 이상의 프로세스가 동시 진입 요청을 한다면 가장 낮은 타임 스탬프를 가지고 있는 프로세스가 가장 먼저 N-1개의 답장을 얻게 되고 진입을 할 수 있게 된다.

Safety 만족 : 진입 요청 메시지가 타임 스탬프에 의해 완전히 정렬되어 있기 때문에    
Liveness, ordering 만족

진입을 하기 위해 2(N-1)개의 메시지가 필요하다, N-1개는 요청에 N-1는 답장에
동기화 딜레이는 1개의 메시지 전송 시간

#### 1.2.4. Maekawa’s voting algorithm
- 프로세스들은 진입하는 권한을 얻기 위해 동료들의 부분 집합에서 허가를 얻으면 된다.
- Voting set Vi 조건
  - Vi는 pi를 포함
  - Vi와 Vj는 무조건 교집합이 있어야 함
  - Vi의 크기는 모두 K
  - 각 프로세스 pj는 M개의 Vi가 포함하고 있다.
- K가 최소인 최적의 해결책 K ~ sqrt(N) 이고, M=K 인 경우

- 진입하기 위해 프로세스는 요청을 Vi의 모든 K개의 멤버에게 보낸다. (자신 포함)
- 그 프로세스는 K개의 답장을 받을 때 까지 진입하지 못한다.
- 만약 다른 프로세스가 어떤 프로세스의 요청을 받았을 경우, HELD 상태 이거나 VOTED=true 이면 
- 아니면, 그 요청을 온 순서대로 큐에 넣고 대답을 하지 않는다.
- 만약 release 메시지를 받으면 큐의 처음을 지우고 그의 대답을 보낸다.
- CS를 나갈 때, 모든 K개의 멤버에게 그 메시지를 보낸다.

Safety 만족 : 알고리즘이 프로세스가 최대 1번 투표를 하게 하기 때문

데드락 당하기 쉽다 : 3개의 프로세스, 2개 씩 있는 3개의 서브셋, 동시의 3 프로세스가 요청해버림

#### Fault tolerance
- 위의 어떤 알고리즘도 메시지의 유실 또는 통신 채널의 신뢰할 수 없는 경우 버틸 수 없다.
- ring-based 알고리즘은 어떤 한 프로세스의 죽음에 버틸 수 없다.
- Maekawa’s 알고리즘은 프로세스 몇 개 좀 죽어도 버틸 수 있다. (?)
- Central server alg은 hold상태이거나 요청 상태가 아닌 클라가 죽으면 버틸 수 있다.

## 3. Elections
어떤 역할을 수행할 고유한 프로세스 선택
- mutual exclusion을 할 중앙 서버
- Ring network의 Ring master

### 3.1. pre-defines
- Partifipant : 어떤 투표 알고리즘의 진행에 참여하고 있음.
- Non-participant : 
- 중요한 요건은 여러 프로세스가 동시에 선거를 호출하더라도 프로세스의 선출이 유일해야 한다는 것이다.
- 가장 큰 id를 가진 프로세스가 선출 된다.
- 속성
  - E1 (safety) : 참여 프로세스는 아무도 선출 하지 않거나 어떤 P를 선출한 상태이어야 하는데 P는 투표 진행의 마지막에 죽지 않은 상태이며 가장 큰 id를 가진 프로세스이어야 한다.
  - E2 (liveness) : 모든 프로세스는 결과적으로 누군가를 선출한 상태이어야 한다.

### 3.2. A ring-based election algorithm
- 각 프로세스는 다음 프로세스와의 통신 채널이 있고 모든 메시지는 시계방향
- Assumption : fail이 일어나지 않고, 시스템은 async
- 이 알고리즘의 목적은 coordinator라고 부르는 가장 큰 id를 가진 한 프로세스를 선출 하는 것이다.

#### 3.2.1. process
- Initial phase
  - 모든 프로세스는 투표에서 비참여로 표시 되어 있다.
  - 자신을 참여로 표시 한 후, 자신의 id를 투표 메시지에 넣어서 시계 방향 이웃에 보낸다.
- 만약 투표 메시지를 받았을 경우
  - 자신의 아이디와 비교
  - 도착한 아이디가 더 클 경우 메시지를 앞으로 보내고 자신을 참여로 표시
  - 도착한 아이디가 작고 비참여 상태 일 경우 메시지의 아이디를 자기 껄로 바꾼 뒤, 앞으로 보낸다.
  - 이미 참여 상태 일 경우 메시지를 보내지 않는다.
- 도착한 아이디가 자기 아이디 일 경우
  - 내 아이디가 가장 크고, 내가 coordinator가 된다.
  - coordinator는 자신을 비 참여로 표시 하고 자신의 아이디를 가지고 있는 선거 결과를 앞으로 보낸다.
- 선거 결과를 받을 경우
  - 자신을 비 참여로 표시하고 자신의 elected 값을 그 아이디로 바꾼 후 앞으로 보낸다.

#### 3.2.2. 속성
- safety는 만족 : 투표 결과를 보내기 전에 자기 아이디를 받기 때문에 모든 아이디를 비교한다.
- liveness도 만족 : 링을 한 바퀴 돌기 때문에

#### 3.2.3. 성능
- 최악의 케이스는 반시계방향 이웃의 아이디가 가장 클 경우
  - 걔 한테 도달 하기 까지 N-1의 메시지가 필요하고 또 한 바퀴 돌려야 되서 추개로 N개가 필요
- 투표 결과는 N번 보내지므로 총 3N-1번의 메시지가 필요
- 총 투표 시간도 3N-1번 인데 메시지가 순서대로 보내지기 때문

### 3.3. bully algorithm
- 투표 중 죽음을 허용한다.
- Assumption
  - 시스템은 sync
  - 프로세스의 failure를 감지하기 위해 timeout 사용
  - 각 프로세스는 누가 자기보다 더 큰 아이디를 가지고 있는지 알고 그들에게 통신 할 수 있음
- 세 가지 종류 메시지
  - Election : 투표 메시지
  - Answer : 투표 메시지의 대답
  - Coordinator : 투표 결과

#### 3.3.1. sync system - reliable failure detector
- 2 trans + process 가 넘으면 죽었다고 간주

#### 3.3.2. process
Election phase
- 낮은 아이디를 가진 프로세스가 투표 메시지를 자기 보다 높은 프로세스들에게 보냄으로 써 투표를 시작한다. 그리고 대답을 기다린다.
- T 시간 안에 아무 대답이 없으면 자기가 짱이라고 생각하고 투표 결과를 자기보다 낮은 프로세스에게 보낸다.
- 아니면 T 시간을 더 기다린 후 새 짱 한테 투표 결과를 받는다.
  - 또 아무 대답이 없으면 투표를 다시 시작한다.
- 투표 메시지를 받으면 답장하고 이미 또 다른 투표를 시작하지 않은 경우 또 다른 투표를 시작한다.

Coordinator phase
- 이미 자기가 짱인 경우 그냥 투표 결과를 낮은 놈들에게 뿌린다.
- 투표 결과를 받은 사람들은 자신의 elected 값을 그 아이디로 바꾼 후 걔를 짱으로 취급

죽은 프로세스를 바꾸려고 할 때
- 그 프로세스는 투표를 시작
- 만약 자기가 짱이면 투표 결과를 뿌린다.
- 현재 짱이 잘 작동하고 있음에도 불구하고 자기가 짱이다. => bully alg (?)

Figure 15.8
- p1이 짱의 죽음을 감지하고 투표 시작
- p2와 p3는 답장하고 자기 만의 투표 시작, p3는 p2에게 답장 p3는 p4에게 답장을 못 받음
- 갑자기 p3가 죽어버림
- p1은 타임 아웃이 되어서 다시 투표 시작
- p2가 짱이 됨.

#### 3.3.3. 속성
safety는 만족 : 아무 프로세스도 교체 되지 않을 경우    
liveness도 만족 : reliable message delivery라고 가정했기 때문    
safety는 동일한 아이디를 가진 프로세스가 죽은 프로세스를 교체하면 만족하지 않는다.
- 동시에 두 프로세스가 자기가 짱이라고 생각하기 때문. (?)

#### 3.3.4. 성능
최고의 경우 두번째로 높은 프로세스가 짱의 죽음을 감지할 경우
- 자기 혼자 투표하고 N-2개의 투표 결과
- 결리는 시간은 1 메시지

최악의 경우 O(N^2)개의 메시지가 필요

## 4. Consensus and related problems
하나 이상의 프로세스가 그 값이 무엇이 되어야 하는지를 제안한 후 값에 합의하는 것

### System model and problem definitions
- 프로세스 p_i (i=1, ..., N) 집합이 메시지 전송을 통해 통신한다.
- fault가 있더라도 합의에 도달해야 함
- 통신은 신뢰할 만하지만 그 과정은 실패할 수 있다.

### Definition of the consensus problem
- 합의에 도달하기 위해 모든 프로세스 pi는 미결정 상태에서 시작하고 단일 값 vi를 제안한다.
- 프로세스 들은 서로 통신하고 값을 교환한다.
- 각 프로세스들은 decision 값 d_i를 설정한다. (decided 상태에 들어감)
- 합의 알고리즘의 요구 사항은 다음과 같다.
  - Termination : 모든 corrent 프로세스는 결국 decision 값을 설정해야 한다.
  - Agreement : 모든 corrent 프로세스들의 decision 값이 같아야 한다.
  - Integrity : 만약 모든 correct 프로세스들이 모드 같은 값을 제안했다면 dicided state에 들어간 모든 corrent 프로레스는 그 값을 가져야 한다.

In figure 15.16    
세 프로세스가 합의 알고리즘에 참여함    
두 프로세스가 '진행'이라고 제안하고 세번째 프로세스가 '중지'라고 제안했지만 죽어버림    
두 프로세스는 correct 상태를 유지하고 있고 '진행'으로 결정이 남.

- 합의를 이루기 위해
  - 프로세스들의 그룹을 이루고 각 프로세스들은 제안하려는 값을 그룹의 멤버들에게 안정되게 전송한다.
  - 각 프로세스들은 N개의 값을 모을 때 까지 대기한다.
  - 각 프로세스는 가장 많이 나온 값을 선정하며 만약 그런 게 없다면 special value를 선정한다.
- 속성
  - Termination : 멀티캐스트 작동의 신뢰성에 의해 보장된다.
  - Agreement and integrity : 다수결의 정의와 신뢰할 수 있는 멀티캐스트의 무결성 속성 보장된다.
- 만약 프로세스가 죽어버리면
  - failure 감자의 복잡성을 야기한다.
  - 합의 알고리즘의 진행이 중지 될 수도 있다.
- 만약 프로세스가 자기 마음대로 실패해버리면
  - Faulty 프로세스는 랜덤 값을 다른 프로세스에게 전송할 수도 있다.

### The byzantine generals problem
- 3명 이상의 장군이 공격이나 후퇴에 동의해야 한다.
- 지휘관인 1명이 명령을 내린다. 다른 부관들, 즉 지휘관의 부관들은 공격하거나 후퇴하기로 결정한다.
- 한 명 이상의 장군을 신뢰 할 수 없을 수도 있다. (faulty)
  - 만약 지회관을 신뢰할 수 없으면 각 장군에게 다른 명령을 내릴 수도 있다.
  - 만약 부관을 신뢰할 수 없으면 그는 그의 동료에게 이상한 명령을 전달 할 수도 있다.
- 비잔틴 장군 문제는 합의와는 다르다.
  - 구별되는 프로세스는 각자가 가치를 제안하는 대신 다른 사람이 합의해야 할 가치를 제공한다.
- 요구 사항
  - Termination : 
  - Agreement : 
  - Integrity : 만약 지휘관이 corrent 하면 다른 모든 corrent 프로세스들은 지휘관이 제시한 값으로 결정해야 한다.

### The byzantine generals problem in a synchronous system
- 만약 프로세스들이 임의적으로 failure 될 수 있다고 가정하자.
- faulty 프로세스는 아무 시간에 아무 값을 보낼 수 있고 보내는 것을 생략할 수도 있다.
- N개의 프로세스 중에 최대 f개가 faulty 될 수 있다.
- corrent 프로세스는 시간 제한을 통해 메시지가 부족하다는 것을 알아 낼 수 있지만 전송자가 죽었다고 결론 내릴 수는 없다. 잠시 쉬었다가 다시 메시지를 보낼 수도 있기 때문이다.
- 만약 서로의 통신 채널이 private하다고 가정하자
  - 어떤 faulty 프로세스도 두 corrent 프로세스 사이의 메시지를 빼내갈 수 없다.
- 세 프로세스가 서명되지 않은 메시지를 서로에게 보내는 경우
  - 한 가지 프로세스가 fail하도록 허용될 경우, 비잔틴 장군 문제의 상황을 충족할 수 있는 해결책은 없다.
  - N <= 3f 일 경우 해결책은 없다.
  - N >= 3f + 1일 경우 해결책이 있다.

### Impossibility with three processes
- 셋 중 하나의 프로세스가 faulty.
- 두 단계의 메시지 : 지휘관이 보낸 값과 부관이 서로에게 보낸 값
- 숫자 접두사 - 메시지 소스와 단계
- ':' 기호가 의미하는거 : says. 3:1:u = 3이 1에게 u라고 말함.
- left-hand 시나리오
  - 부관 중에 하나인 p3가 faulty
  - 지휘관이 두 프로세스에게 v라는 값을 보냄
  - p2가 p3에게 v를 보내지만 p3는 p2에게 u라는 다른 값을 보내버림
  - 이 상태에서 p2는 다른 값을 받았다는 걸 알게 되지만 누가 faulty 된 건지 알 수 없음.
- right-hand 시나리오
  - 지휘관인 p1이 faulty. 각 부관에게 다른 값을 보냄
  - p2와 p3는 옳게 동료에게 값을 전달해 줬지만 각각의 프로세는 서로가 faulty된 것 같은 상황을 맞이한다.

### Solution with one faulty process
- N = 4, f = 1인 경우 해결책
  - 정상적인 장군들은 다음 두 단계를 통해 합의에 도달해야 한다.
    - 1단계 : 지휘관이 각 부관에게 값을 전달.
    - 2단계 : 각 부관이 서로에게 값을 전송
  - 부관은 N-1개의 값을 받는다 : 지휘관에게 받은 값 1개 + 서로에게 받은 값 N-2개
  - 만약 지휘관이 비정상일 경우 모든 정상 부관은 지휘관이 보낸 모든 값을 받게 될 것이다.
  - 만약 부관이 비정상일 경우 서로에게 받은 N-2개의 동일한 값과 비정상 부관이 보낸 값을 받게 될 것이다.
  - left-hand의 경우 : 두 정상 부관이 다수의 값은 v라고 합의를 한다.
  - right-hand의 경우 : 세 정상 부관이 다수의 값은 없다고 합의를 한다.